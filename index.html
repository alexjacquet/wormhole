<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wormhole Simplified</title>
<script>
// EDIT VERSION HERE
const VERSION = "v001";
</script>
<style>
body {
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, sans-serif;
}

#scene {
    position: relative;
    width: 100vw;
    height: 100vh;
    background: radial-gradient(ellipse at center, #000814 0%, #000511 40%, #000000 100%);
}

/* Progress Meter */
.progress-meter {
    position: fixed;
    top: 25px;
    left: 25px;
    z-index: 1001;
    width: 60px;
    height: 60px;
}

.progress-circle {
    position: relative;
    width: 60px;
    height: 60px;
    filter: drop-shadow(0 2px 10px rgba(0, 0, 0, 0.4));
}

.progress-circle svg {
    transform: rotate(-90deg);
    width: 60px;
    height: 60px;
}

.progress-circle .bg-circle {
    fill: none;
    stroke: rgba(255, 255, 255, 0.15);
    stroke-width: 4;
}

.progress-circle .progress-circle-fill {
    fill: none;
    stroke: url(#gradient);
    stroke-width: 4;
    stroke-linecap: round;
    stroke-dasharray: 157.08;
    stroke-dashoffset: 157.08;
    transition: stroke-dashoffset 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.rocket-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 26px;
    filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.6));
}

/* Wormhole */
.wormhole-container {
    position: absolute;
    width: 150px;
    height: 150px;
    left: 50%;
    top: 80%;
    transform: translate(-50%, -50%);
}

.wormhole-container::before {
    content: '';
    position: absolute;
    width: 200%;
    height: 200%;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle at center,
        rgba(69, 132, 255, 0.3) 0%,
        rgba(69, 132, 255, 0.2) 20%,
        rgba(149, 40, 253, 0.1) 40%,
        rgba(0, 0, 0, 0) 70%,
        #000000 100%);
    animation: pulseGlow 4s ease-in-out infinite;
}

@keyframes pulseGlow {
    0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
}

.wormhole-container img {
    width: 100%;
    height: 100%;
    position: relative;
}

/* Emoji Stream */
.emoji {
    position: absolute;
    font-size: 54px;
    user-select: none;
    cursor: pointer;
    z-index: 100;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
}

.emoji.bot {
    filter: drop-shadow(0 0 15px #ff3333) drop-shadow(0 0 25px #ff0000);
    font-size: 58px;
    cursor: crosshair;
}

.emoji.fuel {
    filter: drop-shadow(0 0 15px #00ff88) drop-shadow(0 0 25px #00ddff);
    font-size: 60px;
}

.emoji.choice {
    filter: drop-shadow(0 0 20px rgba(255, 200, 0, 0.5));
    animation: floatChoice 3s ease-in-out infinite;
}

.emoji.choice:hover {
    transform: translate(-50%, -50%) scale(1.2);
    filter: drop-shadow(0 0 30px rgba(255, 200, 0, 0.8));
}

@keyframes floatChoice {
    0%, 100% { transform: translate(-50%, -50%) translateY(0) scale(1); }
    50% { transform: translate(-50%, -50%) translateY(-10px) scale(1.05); }
}

.emoji.sucked { pointer-events: none; }

/* Particle Effects */
.particle {
    position: fixed;
    width: 6px;
    height: 6px;
    background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(149, 40, 253, 0.8) 40%, transparent 70%);
    border-radius: 50%;
    pointer-events: none;
    z-index: 10000;
    box-shadow: 0 0 6px rgba(149, 40, 253, 1), 0 0 12px rgba(69, 132, 255, 0.8);
}

/* Simple Controls */
.controls {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(20, 20, 30, 0.95);
    padding: 15px;
    border-radius: 10px;
    color: white;
    width: 220px;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
}

.controls.collapsed {
    padding: 10px;
    width: auto;
}

.controls.collapsed .control-content {
    display: none;
}

.control-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.controls.collapsed .control-header {
    margin-bottom: 0;
}

.version-text {
    font-size: 12px;
    color: #aaa;
}

.collapse-btn {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 18px;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.collapse-btn:hover {
    color: #4584FF;
}

.control-group {
    margin-bottom: 12px;
}

.control-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 12px;
    color: #aaa;
}

input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: linear-gradient(to right, #9528FD, #4584FF);
    outline: none;
    -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: white;
    cursor: pointer;
}

.mode-btn {
    width: 100%;
    padding: 10px;
    background: linear-gradient(135deg, #00ff88 0%, #00ddff 100%);
    border: none;
    border-radius: 6px;
    color: #000;
    font-size: 14px;
    cursor: pointer;
    font-weight: 700;
    text-transform: uppercase;
}

.toggle-btn {
    width: 100%;
    padding: 8px;
    background: rgba(69, 132, 255, 0.3);
    border: 1px solid #4584FF;
    border-radius: 4px;
    color: white;
    font-size: 12px;
    cursor: pointer;
    margin-top: 5px;
}

.toggle-btn.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: #00ff88;
}

.value { color: #4584FF; font-weight: bold; }
</style>
</head>
<body>
<div id="scene">
    <!-- Progress Meter -->
    <div class="progress-meter">
        <div class="progress-circle">
            <svg>
                <defs>
                    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#9528FD;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#4584FF;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00DDFF;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <circle class="bg-circle" cx="30" cy="30" r="25"/>
                <circle class="progress-circle-fill" cx="30" cy="30" r="25"/>
            </svg>
            <div class="rocket-center">üöÄ</div>
        </div>
    </div>

    <!-- Wormhole -->
    <div class="wormhole-container" id="wormhole">
        <img src="https://storage.googleapis.com/smiletime-dev-cdn-assets/assets/OrbitPrototype/wormholeLooping.gif" alt="Wormhole">
    </div>
</div>

<!-- Controls -->
<div class="controls" id="controls">
    <div class="control-header">
        <span class="version-text" id="versionText"></span>
        <button class="collapse-btn" id="collapseBtn">‚àí</button>
    </div>
    
    <div class="control-content">
        <div class="control-group">
            <button id="modeBtn" class="mode-btn">MODE: üåÄ SUCK</button>
        </div>
        
        <div class="control-group">
            <label>Fuel Emojis (20% boost)</label>
            <button id="fuelToggle" class="toggle-btn active">FUEL: ON</button>
        </div>
        
        <div class="control-group">
            <label>X Position: <span id="xValue" class="value">50</span>%</label>
            <input type="range" id="xSlider" min="20" max="80" value="50">
        </div>
        
        <div class="control-group">
            <label>Y Position: <span id="yValue" class="value">80</span>%</label>
            <input type="range" id="ySlider" min="50" max="90" value="80">
        </div>
        
        <div class="control-group">
            <label>Size: <span id="sizeValue" class="value">260</span>px</label>
            <input type="range" id="sizeSlider" min="150" max="350" value="260">
        </div>
    </div>
</div>

<script>
// Display version
document.getElementById('versionText').textContent = VERSION;

// Configuration
const CONFIG = {
    mode: 'in',
    emojis: ['üé≤', '‚ô•Ô∏è', 'üÉè', '‚ô†Ô∏è', 'üß©', 'ü•≥', '‚ô£Ô∏è', '‚ô¶Ô∏è', 'üéØ', '‚≠ê', 'üé®', 'ü§•', 'üëΩ', 'üëæ', 'üíé'],
    fuelEmojis: ['‚ö°', 'üî•'],
    botEmoji: 'ü§ñ',
    fuelEnabled: true,
    wormhole: { x: 50, y: 80, size: 260, gravity: 258 },
    spawnRate: 1200,
    emissionRange: 40,
    progress: 0
};

// Progress Meter
class ProgressMeter {
    constructor() {
        this.progress = 0;
        this.circle = document.querySelector('.progress-circle-fill');
    }
    
    update(value) {
        const oldProgress = this.progress;
        this.progress = Math.max(0, Math.min(100, value));
        
        if (oldProgress !== this.progress) {
            console.log(`Progress: ${Math.floor(this.progress)}%`);
        }
        
        const circumference = 2 * Math.PI * 25;
        const offset = circumference - (this.progress / 100) * circumference;
        this.circle.style.strokeDashoffset = offset;
    }
    
    add(points) { this.update(this.progress + points); }
    damage(points) { this.update(this.progress - points); }
    reset() { this.update(0); }
}

// Wormhole
class Wormhole {
    constructor() {
        this.element = document.getElementById('wormhole');
        this.updatePosition();
        this.updateSize();
    }
    
    updatePosition() {
        this.element.style.left = `${CONFIG.wormhole.x}%`;
        this.element.style.top = `${CONFIG.wormhole.y}%`;
    }
    
    updateSize() {
        const scale = CONFIG.wormhole.size / 150;
        this.element.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }
    
    getCenter() {
        const rect = this.element.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
            radius: (CONFIG.wormhole.size / 150) * 75
        };
    }
}

// Particle Effects
class Particles {
    static createExplosion(x, y, isFuel = false, targetPos = null, onReady = null, isBot = false) {
        if (isBot) {
            // Red bot explosion
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.cssText = `
                    position: fixed;
                    width: 8px;
                    height: 8px;
                    left: ${x}px;
                    top: ${y}px;
                    border-radius: 50%;
                    background: radial-gradient(circle, #ff3333 0%, #ff0000 50%, transparent 70%);
                    box-shadow: 0 0 10px #ff0000;
                    pointer-events: none;
                    z-index: 10000;
                `;
                document.body.appendChild(particle);
                
                const angle = (Math.PI * 2 * i) / 20;
                const speed = 3 + Math.random() * 4;
                const distance = speed * 20;
                const endX = x + Math.cos(angle) * distance;
                const endY = y + Math.sin(angle) * distance;
                
                setTimeout(() => {
                    particle.style.transition = 'all 400ms ease-out';
                    particle.style.left = endX + 'px';
                    particle.style.top = endY + 'px';
                    particle.style.opacity = '0';
                    particle.style.transform = 'scale(0.5)';
                    setTimeout(() => particle.remove(), 400);
                }, 10);
            }
            return;
        }
        
        // Regular/fuel explosion with trails
        const particleCount = isFuel ? 35 : 25;
        const particles = [];
        const startTime = performance.now();
        let pointsAdded = false;
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            const isStreaker = Math.random() < 0.2;
            const size = isStreaker ? 4 + Math.random() * 6 : 3 + Math.random() * 5;
            
            particle.style.width = size + 'px';
            particle.style.height = size + 'px';
            
            const hue = isFuel ? 
                (isStreaker ? 15 + Math.random() * 30 : 30 + Math.random() * 30) :
                (isStreaker ? 270 + Math.random() * 30 : 250 + Math.random() * 60);
            const lightness = isStreaker ? 60 + Math.random() * 20 : 50 + Math.random() * 30;
            
            particle.style.background = `radial-gradient(circle, hsl(${hue}, 100%, ${lightness}%) 0%, transparent 60%)`;
            particle.style.boxShadow = `0 0 ${size * 2}px hsla(${hue}, 100%, ${lightness}%, 0.5)`;
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            
            document.body.appendChild(particle);
            
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            const angle = i * goldenAngle + (Math.random() - 0.5) * 0.3;
            const speed = isStreaker ? 5 + Math.random() * 4 : 3 + Math.random() * 3;
            
            particles.push({
                element: particle,
                startX: x,
                startY: y,
                x: x,
                y: y,
                angle: angle,
                speed: speed,
                size: size,
                birthDelay: i * 10,
                born: false,
                targetX: targetPos ? targetPos.x : x,
                targetY: targetPos ? targetPos.y : y,
                isStreaker: isStreaker,
                prevX: x,
                prevY: y,
                trail: null
            });
        }
        
        function animate() {
            const now = performance.now();
            const elapsed = now - startTime;
            let activeParticles = false;
            
            particles.forEach(p => {
                if (elapsed < p.birthDelay) return;
                
                if (!p.born) {
                    p.born = true;
                    p.bornTime = elapsed;
                }
                
                const age = elapsed - p.bornTime;
                const explodeDuration = 300;
                const pauseDuration = 100;
                const convergeDuration = 500;
                const totalDuration = explodeDuration + pauseDuration + convergeDuration;
                
                if (age < totalDuration) {
                    activeParticles = true;
                    
                    let x, y, scale, opacity;
                    
                    if (age < explodeDuration) {
                        // Explosion phase
                        const progress = 1 - Math.pow(1 - age / explodeDuration, 3);
                        const distance = p.speed * 30 * progress;
                        x = p.startX + Math.cos(p.angle) * distance;
                        y = p.startY + Math.sin(p.angle) * distance;
                        scale = 1 + progress * 0.5;
                        opacity = 1;
                    } else if (age < explodeDuration + pauseDuration) {
                        // Pause phase
                        const explodeDistance = p.speed * 30;
                        x = p.startX + Math.cos(p.angle) * explodeDistance;
                        y = p.startY + Math.sin(p.angle) * explodeDistance;
                        scale = 1.5;
                        opacity = 1;
                    } else {
                        // Convergence phase
                        const convergeProgress = Math.pow((age - explodeDuration - pauseDuration) / convergeDuration, 2);
                        const explodeDistance = p.speed * 30;
                        const explodeX = p.startX + Math.cos(p.angle) * explodeDistance;
                        const explodeY = p.startY + Math.sin(p.angle) * explodeDistance;
                        
                        const midX = (explodeX + p.targetX) / 2;
                        const midY = explodeY - 50;
                        const t = convergeProgress;
                        x = (1-t)*(1-t)*explodeX + 2*(1-t)*t*midX + t*t*p.targetX;
                        y = (1-t)*(1-t)*explodeY + 2*(1-t)*t*midY + t*t*p.targetY;
                        
                        scale = 1.5 * (1 - convergeProgress * 0.8);
                        opacity = convergeProgress < 0.7 ? 1 : 1 - ((convergeProgress - 0.7) / 0.3);
                        
                        // Create trails for streakers
                        if (p.isStreaker && convergeProgress > 0.1) {
                            if (!p.trail) {
                                p.trail = document.createElement('div');
                                p.trail.style.position = 'fixed';
                                p.trail.style.pointerEvents = 'none';
                                p.trail.style.zIndex = '9999';
                                document.body.appendChild(p.trail);
                            }
                            
                            const dx = x - p.prevX || 0;
                            const dy = y - p.prevY || 0;
                            const angle = Math.atan2(dy, dx);
                            const speed = Math.sqrt(dx * dx + dy * dy);
                            const trailLength = Math.min(speed * 8, 80);
                            
                            p.trail.style.width = trailLength + 'px';
                            p.trail.style.height = p.size + 'px';
                            p.trail.style.left = (x - Math.cos(angle) * trailLength/2) + 'px';
                            p.trail.style.top = y + 'px';
                            p.trail.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
                            p.trail.style.background = `linear-gradient(90deg, transparent 0%, ${isFuel ? 'rgba(255, 200, 0, 0.6)' : 'rgba(149, 40, 253, 0.6)'} 100%)`;
                            p.trail.style.filter = `blur(${p.size * 0.3}px)`;
                            p.trail.style.opacity = opacity;
                            
                            p.prevX = x;
                            p.prevY = y;
                        }
                        
                        if (!pointsAdded && convergeProgress > 0.65 && onReady) {
                            pointsAdded = true;
                            onReady();
                        }
                    }
                    
                    p.element.style.left = x + 'px';
                    p.element.style.top = y + 'px';
                    p.element.style.transform = `translate(-50%, -50%) scale(${scale})`;
                    p.element.style.opacity = opacity;
                } else if (p.element.parentNode) {
                    p.element.remove();
                    if (p.trail) p.trail.remove();
                }
            });
            
            if (activeParticles) {
                requestAnimationFrame(animate);
            }
        }
        
        requestAnimationFrame(animate);
    }
}

// Emoji Stream
class EmojiStream {
    constructor() {
        this.emojis = [];
        this.activeChoices = [];
        this.lastSpawnTime = 0;
        this.animationId = null;
        this.init();
    }
    
    init() {
        this.startPhysics();
        
        // Initial spawns
        if (CONFIG.mode === 'in' || CONFIG.mode === 'invasion') {
            setTimeout(() => this.spawn(), 200);
            setTimeout(() => this.spawn(), 800);
            setTimeout(() => this.spawn(), 1400);
        } else if (CONFIG.mode === 'out') {
            setTimeout(() => this.spawn(), 500);
            setTimeout(() => this.spawn(), 1000);
        } else if (CONFIG.mode === 'pick') {
            setTimeout(() => this.spawnChoices(), 500);
        }
    }
    
    spawn() {
        const now = Date.now();
        const cooldown = CONFIG.spawnRate * (0.85 + Math.random() * 0.6);
        
        if (now - this.lastSpawnTime < cooldown) return;
        
        const emoji = document.createElement('div');
        emoji.className = 'emoji';
        
        const isFuel = CONFIG.fuelEnabled && Math.random() < 0.1 && CONFIG.fuelEmojis.length > 0;
        const pool = isFuel ? CONFIG.fuelEmojis : CONFIG.emojis;
        emoji.textContent = pool[Math.floor(Math.random() * pool.length)];
        
        if (isFuel) emoji.classList.add('fuel');
        
        let emojiData;
        
        if (CONFIG.mode === 'in' || CONFIG.mode === 'invasion') {
            // Spawn from left
            const startX = -60;
            const wormholeY = (CONFIG.wormhole.y / 100) * window.innerHeight;
            const rangePixels = (CONFIG.emissionRange / 100) * window.innerHeight;
            const startY = Math.max(50, wormholeY - rangePixels) + Math.random() * rangePixels;
            
            emojiData = {
                element: emoji,
                x: startX,
                y: startY,
                vx: (2 + Math.random()) * (isFuel ? 1.4 : 1),
                vy: (Math.random() - 0.5) * 0.3,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 3,
                scale: 1,
                beingSucked: false,
                suckStartTime: null,
                isFuel: isFuel,
                value: isFuel ? 20 : 5
            };
            
            emoji.style.left = `${startX}px`;
            emoji.style.top = `${startY}px`;
        } else {
            // Spawn from wormhole center
            const center = wormhole.getCenter();
            const angle = Math.PI * 1.25 + (Math.random() - 0.5) * Math.PI * 0.5;
            const speed = (2 + Math.random() * 2.5) * (isFuel ? 1.5 : 1);
            
            emojiData = {
                element: emoji,
                x: center.x,
                y: center.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 0.5,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 5,
                scale: 0,
                age: 0,
                isFuel: isFuel,
                value: isFuel ? 20 : 5
            };
            
            emoji.style.left = `${center.x}px`;
            emoji.style.top = `${center.y}px`;
            emoji.style.transform = 'translate(-50%, -50%) scale(0)';
        }
        
        emoji.onclick = (e) => {
            e.stopPropagation();
            if (emojiData.beingSucked) return;
            
            const rect = emoji.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            const meterPos = { x: 55, y: 55 };
            
            Particles.createExplosion(x, y, emojiData.isFuel, meterPos, () => {
                progressMeter.add(emojiData.value);
            });
            
            this.emojis.splice(this.emojis.indexOf(emojiData), 1);
            emoji.remove();
        };
        
        scene.appendChild(emoji);
        this.emojis.push(emojiData);
        this.lastSpawnTime = now;
    }
    
    spawnBot() {
        const emoji = document.createElement('div');
        emoji.className = 'emoji bot';
        emoji.textContent = CONFIG.botEmoji;
        
        const startX = -60;
        const wormholeY = (CONFIG.wormhole.y / 100) * window.innerHeight;
        const startY = wormholeY - Math.random() * 200;
        
        const emojiData = {
            element: emoji,
            x: startX,
            y: startY,
            vx: 3 + Math.random(),
            vy: (Math.random() - 0.5) * 0.5,
            rotation: 0,
            rotationSpeed: (Math.random() - 0.5) * 4,
            scale: 1,
            beingSucked: false,
            isBot: true
        };
        
        emoji.style.left = `${startX}px`;
        emoji.style.top = `${startY}px`;
        
        emoji.onclick = (e) => {
            e.stopPropagation();
            const rect = emoji.getBoundingClientRect();
            Particles.createExplosion(rect.left + rect.width/2, rect.top + rect.height/2, false, null, null, true);
            this.emojis.splice(this.emojis.indexOf(emojiData), 1);
            emoji.remove();
        };
        
        scene.appendChild(emoji);
        this.emojis.push(emojiData);
    }
    
    spawnChoices() {
        if (this.activeChoices.length > 0) return;
        
        const center = wormhole.getCenter();
        const chosen = [];
        const pool = [...CONFIG.emojis, ...(CONFIG.fuelEnabled ? CONFIG.fuelEmojis : [])];
        
        while (chosen.length < 3 && chosen.length < pool.length) {
            const emoji = pool[Math.floor(Math.random() * pool.length)];
            if (!chosen.includes(emoji)) chosen.push(emoji);
        }
        
        chosen.forEach((emojiText, i) => {
            const emoji = document.createElement('div');
            emoji.className = 'emoji choice';
            emoji.textContent = emojiText;
            
            const isFuel = CONFIG.fuelEmojis.includes(emojiText);
            if (isFuel) emoji.classList.add('fuel');
            
            const angle = Math.PI * 0.85 + (Math.PI * 0.35 * i / 2);
            const distance = 160 + i * 45;
            const targetX = center.x + Math.cos(angle) * distance;
            const targetY = center.y + Math.sin(angle) * distance;
            
            emoji.style.left = `${center.x}px`;
            emoji.style.top = `${center.y}px`;
            emoji.style.transform = 'translate(-50%, -50%) scale(0)';
            emoji.style.opacity = '0';
            
            const emojiData = {
                element: emoji,
                isFuel: isFuel,
                value: isFuel ? 20 : 5
            };
            
            emoji.onclick = (e) => {
                e.stopPropagation();
                const rect = emoji.getBoundingClientRect();
                const meterPos = { x: 55, y: 55 };
                
                Particles.createExplosion(rect.left + rect.width/2, rect.top + rect.height/2, isFuel, meterPos, () => {
                    progressMeter.add(emojiData.value);
                });
                
                this.activeChoices.forEach(c => c.element.remove());
                this.activeChoices = [];
                
                setTimeout(() => this.spawnChoices(), 2000);
            };
            
            scene.appendChild(emoji);
            this.activeChoices.push(emojiData);
            
            setTimeout(() => {
                emoji.style.transition = 'all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1)';
                emoji.style.left = `${targetX}px`;
                emoji.style.top = `${targetY}px`;
                emoji.style.transform = 'translate(-50%, -50%) scale(1)';
                emoji.style.opacity = '1';
            }, 50 + i * 100);
        });
    }
    
    updatePhysics() {
        // Spawn logic
        if (CONFIG.mode === 'pick') {
            // Handled by spawnChoices
        } else if (CONFIG.mode === 'invasion') {
            if (Math.random() < 0.02) this.spawn();
            if (Math.random() < 0.008) this.spawnBot();
        } else {
            if (Math.random() < 0.02) this.spawn();
        }
        
        const center = wormhole.getCenter();
        
        for (let i = this.emojis.length - 1; i >= 0; i--) {
            const emoji = this.emojis[i];
            
            if (CONFIG.mode === 'in' || CONFIG.mode === 'invasion') {
                // Suck mode physics
                const dx = center.x - emoji.x;
                const dy = center.y - emoji.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (emoji.beingSucked) {
                    const elapsed = Date.now() - emoji.suckStartTime;
                    const progress = Math.min(elapsed / 350, 1);
                    
                    emoji.x += dx * progress * progress * 0.5;
                    emoji.y += dy * progress * progress * 0.5;
                    emoji.scale = Math.max(0, 1 - progress);
                    emoji.rotation += 10 + progress * 20;
                    
                    if (progress >= 1) {
                        if (emoji.isBot) progressMeter.damage(10);
                        emoji.element.remove();
                        this.emojis.splice(i, 1);
                        continue;
                    }
                } else {
                    if (distance < center.radius * 0.7) {
                        emoji.beingSucked = true;
                        emoji.suckStartTime = Date.now();
                        emoji.element.classList.add('sucked');
                        continue;
                    }
                    
                    const force = (CONFIG.wormhole.gravity * CONFIG.wormhole.gravity) / (distance * distance);
                    emoji.vx += (dx / distance) * force * 0.02;
                    emoji.vy += (dy / distance) * force * 0.025;
                    
                    if (distance < CONFIG.wormhole.gravity * 1.2) {
                        emoji.vx += (-dy / distance) * force * 0.008;
                        emoji.vy += (dx / distance) * force * 0.008;
                    }
                }
                
                emoji.x += emoji.vx * 0.5;
                emoji.y += emoji.vy * 0.5;
                emoji.rotation += emoji.rotationSpeed;
                
                emoji.element.style.left = `${emoji.x}px`;
                emoji.element.style.top = `${emoji.y}px`;
                emoji.element.style.transform = `translate(-50%, -50%) rotate(${emoji.rotation}deg) scale(${emoji.scale})`;
            } else if (CONFIG.mode === 'out') {
                // Blow mode physics
                emoji.age = (emoji.age || 0) + 1;
                
                if (emoji.age < 30) {
                    emoji.scale = emoji.age / 30;
                    emoji.rotation = emoji.scale * 360;
                } else {
                    emoji.scale = 1;
                    emoji.rotation += emoji.rotationSpeed;
                }
                
                emoji.vx *= 1.002;
                emoji.vy *= 1.002;
                emoji.vx += Math.sin(emoji.age * 0.05) * 0.02;
                emoji.vy += Math.cos(emoji.age * 0.05) * 0.02;
                
                emoji.x += emoji.vx * 0.5;
                emoji.y += emoji.vy * 0.5;
                
                emoji.element.style.left = `${emoji.x}px`;
                emoji.element.style.top = `${emoji.y}px`;
                emoji.element.style.transform = `translate(-50%, -50%) rotate(${emoji.rotation}deg) scale(${emoji.scale})`;
            }
            
            // Remove if off screen
            if (emoji.x < -200 || emoji.x > window.innerWidth + 200 ||
                emoji.y < -200 || emoji.y > window.innerHeight + 200) {
                emoji.element.remove();
                this.emojis.splice(i, 1);
            }
        }
        
        this.animationId = requestAnimationFrame(() => this.updatePhysics());
    }
    
    startPhysics() {
        if (!this.animationId) this.updatePhysics();
    }
    
    reset() {
        this.emojis.forEach(e => e.element.remove());
        this.activeChoices.forEach(e => e.element.remove());
        this.emojis = [];
        this.activeChoices = [];
        this.lastSpawnTime = 0;
        
        if (CONFIG.mode === 'pick') {
            setTimeout(() => this.spawnChoices(), 500);
        }
    }
}

// Initialize
const scene = document.getElementById('scene');
const progressMeter = new ProgressMeter();
const wormhole = new Wormhole();
const emojiStream = new EmojiStream();

// Controls
document.getElementById('modeBtn').onclick = () => {
    const modes = ['in', 'out', 'pick', 'invasion'];
    const modeNames = { in: 'üåÄ SUCK', out: '‚ú® BLOW', pick: 'üéØ PICK 1', invasion: 'ü§ñ INVASION' };
    const currentIndex = modes.indexOf(CONFIG.mode);
    CONFIG.mode = modes[(currentIndex + 1) % modes.length];
    document.getElementById('modeBtn').textContent = `MODE: ${modeNames[CONFIG.mode]}`;
    emojiStream.reset();
};

document.getElementById('fuelToggle').onclick = (e) => {
    CONFIG.fuelEnabled = !CONFIG.fuelEnabled;
    e.target.classList.toggle('active');
    e.target.textContent = `FUEL: ${CONFIG.fuelEnabled ? 'ON' : 'OFF'}`;
};

document.getElementById('xSlider').oninput = (e) => {
    CONFIG.wormhole.x = e.target.value;
    document.getElementById('xValue').textContent = e.target.value;
    wormhole.updatePosition();
};

document.getElementById('ySlider').oninput = (e) => {
    CONFIG.wormhole.y = e.target.value;
    document.getElementById('yValue').textContent = e.target.value;
    wormhole.updatePosition();
};

document.getElementById('sizeSlider').oninput = (e) => {
    CONFIG.wormhole.size = e.target.value;
    document.getElementById('sizeValue').textContent = e.target.value;
    wormhole.updateSize();
};

// Collapse/Expand Controls
document.getElementById('collapseBtn').onclick = () => {
    const controls = document.getElementById('controls');
    const btn = document.getElementById('collapseBtn');
    
    controls.classList.toggle('collapsed');
    btn.textContent = controls.classList.contains('collapsed') ? '+' : '‚àí';
};
</script>
</body>
</html>
